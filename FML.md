Макрофайл - текстовый файл с расширением FML. Каждая конструкция макрофайла
начинается с соответствующего ключевого слова. Все ключевые слова и
идентификаторы, описываемые в макрофайлах - регистронезависимы.

### Комментарии ###

Поддерживаются однострочные и многострочные комментарии. Однострочные
комментарии начинаются с ;; или //. Многострочные комментарии
ограничиваются `/*` ... `*/`, вложенные многострочные комментарии
не поддерживаются. Все типы комментариев могут использоваться
в любом месте макрофайла, в том числе - в  тексте макропоследовательности.

### Константы ###

Описание константы начинается с ключевого слова Const:
```
  const dlgFindFile = "{8C9EAD29-910F-4b24-A669-EDAFBA6ED964}"
  const EdtFind = 0x444E4645
  const faReadOnly = 1
```
Строковые литералы могут заключаться в одинарные или двойные кавычки.
Для использования той-же кавычки внутри литерала она удваивается.

Константы можно использовать при задании макрообластей (см. далее),
а также в тексте макропоследовательности в формате #%ИмяКонстанты,
подробнее в описании препроцессора. Зона видимости констант: с момента
описания до конца разбора макрофайла. Повторное описание - недопустимо.


### Включения (Include) ###

К макрофайлу можно подключить другой файл с помощью оператора Include.

Если оператор Include встречается _не_ в тексте маропоследовательности,
то включаемый файл должен иметь синтаксис макрофайла. Расширение включаемого
файла может быть любым, но рекомендуется использовать расширение .FMI
(Far Macro Include). Не рекомендуется давать включаемому файлу расширение FML,
так как в этом случае он может начать обрабатываться как самостоятельный
макрофайл, что, обычно, нежелательно. Путь к включаемому файлу задается
относительно включающего файла. Допустимо использование переменных окружения.
Include могут быть вложенными, глубина вложенности - не ограничена. Рекурсия,
естественно, недопустима.

Примеры:
```
  include "Consts.fmi"
  include "%FarHome%\Macros\Library.fmi"
```

Также возможно подключение файлов в тексте макропоследовательности. Для этого
используется оператор #Include. В этом случае включаемый файл должен иметь
синтаксис "plain-text" макро. Пример:
```
  Macro Descr="Select same filenames on both panels" Area="Shell" 
  {{
    #Include "Compare.macro"
  }}
```

Замечание: при использовании оператора #Include в тексте макропоследовательности
любые ошибки при проверке макроса приведут к неправильному позиционированию
при открытии текстового редактора.


### Макросы ###

Описание макроса начинается с ключевого слова Macro. Обобщенный формат макроса:
```
  Macro Parameter1="StrValue" Parameter2=IntValue
  {{
    Текст макропоследовательности
  }}
```
Параметры (некоторые параметры имеют несколько синонимов):

  * **Name**
> > Имя макроса, используется для вызова макросов из командной строки или из других макросов.

  * **Description**, **Descr**
> > Описание макроса

  * **Area**, **Areas**
> > Макро область. Допустимо указание нескольких областей, через пробел.
> > Если опущено, то макрос срабатывает во всех областях.<br>
<blockquote>Возможные значения:<br>
<pre><code>     Shell, Editor, Viewer, Dialog, Menu, MainMenu, UserMenu, <br>
     Help, QView, Info, Tree, Disks, Search, FFolder, ACompl<br>
</code></pre>
Для макрообласти Dialog дополнительно можно указать GUID диалога,<br>
в формате "Dialog.GUID". GUID можно указывать непосредственно в<br>
строке, либо использовать ранее описанную константу. Например,<br>
для диалога поиска:<br>
<pre><code>     Area="Dialog.{8C9EAD29-910F-4B24-A669-EDAFBA6ED964}" <br>
</code></pre>
или<br>
<pre><code>     Area="Dialog.dlgFindFile"<br>
</code></pre>
Для диалогов, не снабженных GUID возможен альтернативный способ привязки - по заголовку. Заголовок можно указать непосредственно в строке, заключив его в кавычки, или с помощью константы. При указании заголовка допустимо использование масок "<code>*</code>" и "?". Пример:<br>
<pre><code>     Area="Dialog.'Macroses*'" <br>
</code></pre>
Для макрообластей Editor и Viewer возможна привязка к определенному типу файлов. Типы определяются по маске, которая задается аналогично заголовкам диалога. Пример:<br>
<pre><code>     Area="Editor.'*.fml'"<br>
</code></pre></blockquote></li></ul>

<ul><li><b>Bind</b>, <b>Key</b>, <b>Keys</b>, <b>Hotkey</b>, <b>Hotkeys</b>
<blockquote>Горячая клавиша для запуска, в формате FAR, например: "CtrlAltF12"<br>
Допустимо указание нескольких клавиш, через пробел. Если опущено,<br>
макрос может быть вызван только через меню.<br>
</blockquote><blockquote>Для каждой горячей клавиши может быть указан модификатор, отделенный символом ":". Список возможных модификаторов:<br>
<ol><li>Single  - Макрос срабатывает только при однократном нажатии клавиши или кнопки мыши<br>
</li><li>Double  - Макрос срабатывает при двойном нажатии клавиши или кнопки мыши<br>
</li><li>Hold    - Макрос срабатывает при удержании клавиши в течении N мс. Период настраивается в реестре. Для кнопок мыши - игнорируется<br>
</li><li>Release - Макрос срабатывает при отпускании клавиши или кнопки мыши<br>
</li></ol>Пример:<br>
<pre><code>     Bind="MSRClick:Release"<br>
</code></pre></blockquote></li></ul>

<ul><li><b>Event</b>, <b>Events</b>
<blockquote>Альтернативный способ запуска макросов - по событию. В текущей версии поддерживается только один тип события "Open". Если это событие назначено для области Shell, то макрос исполняется один раз при запуске FAR. Если событие назначено для областей Editor, Viewer или Dialog то макрос исполняется каждый раз при открытии соответствующего окна. Для других областей событие игнорируется.</blockquote></li></ul>

<ul><li><b>Condition</b>, <b>Cond</b>
<blockquote>Условия срабатывания макроса. Строка условий имеет формат:<br>
<blockquote>"Условие:0 Условие:1 ..."<br>
</blockquote>Если заданы несколько условий, то макрос запустится только если выполняются все условия (т.е. условия объединяются по and). Возможные варианты условий:<br>
<ol><li>CmdLine:0/1   - Командная строка пуста/не пуста<br>
</li><li>Selected:0/1  - не отмечен/отмечен блок в редакторе, программе просмотра, в строках ввода в диалогах.<br>
</li><li>PanelType:0/1     - Текущая панель: 0 - файловая, 1 - плагинная<br>
</li><li>PanelItem:0/1     - Текущий элемент панели: 0 - файл, 1 - папка<br>
</li><li>PanelSelected:0/1 - нет/есть выделение на текущей панели<br>
</li></ol><blockquote>PPanelType, PPanelItem, PPanelSelected - аналогично, для пассивной панели</blockquote></blockquote></li></ul>

<ul><li><b>Priority</b>=N, по умолчанию 0<br>
<blockquote>Приоритет макроса. Если под условия срабатывания попало сразу несколько макросов, то будет исполнен макрос, обладающий наибольшим приоритетом. Если имеется несколько макросов с одинаковым приоритетом, то будет показан диалог со списком макросов и предложено выбрать один из них.</blockquote></li></ul>

<ul><li><b>DisableOutput</b>=0/1, по умолчанию 1<br>
</li><li><b>SendToPlugin</b>=0/1, по умолчанию 1<br>
<blockquote>Режимы исполнения макроса (см. документацию FAR)</blockquote></li></ul>

<ul><li><b>RunOnRelease</b>=0/1, по умолчанию 0<br>
<blockquote>Если = 1, то макрос будет исполняться не при нажатии, а при отпускании горячей клавиши или кнопки мыши. Полезно при назначении макросов на однократное нажатие префиксных клавиш Ctrl/Alt/Shift.<br>
</blockquote><blockquote>Опция оставлена для совместимости. Вместо нее рекомендуется пользоваться модификатором клавиш "Release".</blockquote></li></ul>

<ul><li><b>EatOnRun</b>=0/1, по умолчанию 1<br>
<blockquote>Если = 1 то событие вызвавшее макрос (нажатие горячей клавиши или событие мыши) будет удалено из очереди сообщений и не попадет в FAR.</blockquote></li></ul>

<h3>Макропоследовательность ###

Перед тем как быть переданной на проверку или исполнение FAR'у текст макропоследовательности проходит предварительную обработку (препроцессинг). На этом этапе:
  1. Удаляются все комментарии.
  1. Обрабатываются операторы #Include
  1. Макроконстанты #%Name раскрываются до значений
  1. Обрабатывается макроподстановка #AKey

Макроподстановка #AKey раскрывается в цифровой код клавиши, вызвавшей макрос, т.е. она аналогична вызову функции AKey(0). Для того чтобы получить имя клавиши, используйте Key(#AKey), а вместо $AKey - Eval(Key(#AKey)).

Препроцессор не делает полноценный разбор макроса (этим занимается сам FAR). Он лишь выделяет из текста макроса свои конструкции (комментарии и операторы, начинающиеся с символа "#")